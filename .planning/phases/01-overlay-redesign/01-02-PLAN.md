---
phase: 01-overlay-redesign
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/settings.rs
  - src-tauri/src/overlay.rs
autonomous: true

must_haves:
  truths:
    - "FollowCursor is a valid overlay position option"
    - "When FollowCursor is selected, overlay appears near cursor position"
    - "Overlay stays within screen bounds (clamped)"
    - "Top and Bottom positions still work correctly"
    - "None position hides overlay entirely"
  artifacts:
    - path: "src-tauri/src/settings.rs"
      provides: "FollowCursor enum variant"
      contains: "FollowCursor"
    - path: "src-tauri/src/overlay.rs"
      provides: "Cursor-relative positioning logic"
      contains: "FollowCursor"
  key_links:
    - from: "src-tauri/src/overlay.rs"
      to: "src-tauri/src/settings.rs"
      via: "OverlayPosition enum import"
      pattern: "use crate::settings::OverlayPosition"
    - from: "calculate_overlay_position"
      to: "Enigo mouse location"
      via: "enigo.location()"
      pattern: "enigo.*location"
---

<objective>
Add FollowCursor positioning mode to the overlay system, allowing the overlay to appear near the user's cursor when recording starts.

Purpose: Give users flexibility in overlay placement - top, bottom, near cursor, or hidden entirely.
Output: Extended OverlayPosition enum with FollowCursor variant and cursor-relative positioning logic in overlay.rs.
</objective>

<execution_context>
@C:\Users\hsbaz\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hsbaz\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-overlay-redesign/01-RESEARCH.md
@src-tauri/src/settings.rs
@src-tauri/src/overlay.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FollowCursor to OverlayPosition enum</name>
  <files>src-tauri/src/settings.rs</files>
  <action>
Update src-tauri/src/settings.rs to add the FollowCursor option:

1. Find the OverlayPosition enum (around line 16-22):
```rust
#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum OverlayPosition {
    None,
    Top,
    Bottom,
}
```

2. Add FollowCursor variant:
```rust
#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum OverlayPosition {
    None,
    Top,
    Bottom,
    FollowCursor,
}
```

That's it for this file. The serde rename_all = "lowercase" will serialize it as "followcursor" in JSON.

NOTE: Do NOT change the default_overlay_position() function - it should still default to Bottom (or None on Linux). FollowCursor is an opt-in setting.
  </action>
  <verify>
Run `cargo check --manifest-path src-tauri/Cargo.toml` to verify Rust compiles without errors.
  </verify>
  <done>
OverlayPosition enum includes FollowCursor variant that serializes to "followcursor" in settings JSON.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement cursor-relative positioning in overlay.rs</name>
  <files>src-tauri/src/overlay.rs</files>
  <action>
Update src-tauri/src/overlay.rs to support FollowCursor positioning:

0. First, verify import exists at top of file:
   Ensure `use enigo::{Enigo, Mouse};` import is present (required for cursor position detection via enigo.location())

1. Update calculate_overlay_position() function to handle FollowCursor:

Replace the current implementation with this enhanced version that handles all position modes:

```rust
fn calculate_overlay_position(app_handle: &AppHandle) -> Option<(f64, f64)> {
    let settings = settings::get_settings(app_handle);
    let monitor = get_monitor_with_cursor(app_handle)?;

    let work_area = monitor.work_area();
    let scale = monitor.scale_factor();
    let work_area_width = work_area.size.width as f64 / scale;
    let work_area_height = work_area.size.height as f64 / scale;
    let work_area_x = work_area.position.x as f64 / scale;
    let work_area_y = work_area.position.y as f64 / scale;

    let (x, y) = match settings.overlay_position {
        OverlayPosition::FollowCursor => {
            // Get cursor position
            let cursor_pos = Enigo::new(&Default::default())
                .ok()
                .and_then(|e| e.location().ok());

            if let Some((cx, cy)) = cursor_pos {
                // Position below cursor with 40px offset
                let cursor_x = cx as f64 / scale;
                let cursor_y = cy as f64 / scale;

                // Center overlay horizontally on cursor, but clamp to screen bounds
                let x = (cursor_x - OVERLAY_WIDTH / 2.0).clamp(
                    work_area_x,
                    work_area_x + work_area_width - OVERLAY_WIDTH
                );

                // Position below cursor with offset, clamp to screen bounds
                let y = (cursor_y + 40.0).clamp(
                    work_area_y,
                    work_area_y + work_area_height - OVERLAY_HEIGHT
                );

                (x, y)
            } else {
                // Fallback to center-bottom if cursor position unavailable
                let x = work_area_x + (work_area_width - OVERLAY_WIDTH) / 2.0;
                let y = work_area_y + work_area_height - OVERLAY_BOTTOM_OFFSET;
                (x, y)
            }
        },
        OverlayPosition::Top => {
            let x = work_area_x + (work_area_width - OVERLAY_WIDTH) / 2.0;
            let y = work_area_y + OVERLAY_TOP_OFFSET;
            (x, y)
        },
        OverlayPosition::Bottom | OverlayPosition::None => {
            let x = work_area_x + (work_area_width - OVERLAY_WIDTH) / 2.0;
            let y = work_area_y + work_area_height - OVERLAY_BOTTOM_OFFSET;
            (x, y)
        }
    };

    Some((x, y))
}
```

Key implementation notes:
- Cursor position is only fetched when FollowCursor mode is active (not for Top/Bottom)
- Position is clamped to work_area bounds to prevent off-screen placement
- Fallback to center-bottom if Enigo fails to get cursor position
- Scale factor is applied to cursor position for HiDPI support

2. Update OVERLAY_HEIGHT constant to match new CSS height:
   Change from 42.0 to 48.0:
```rust
const OVERLAY_HEIGHT: f64 = 48.0;
```

3. Update OVERLAY_WIDTH to match new min-width:
   Change from 220.0 to 240.0:
```rust
const OVERLAY_WIDTH: f64 = 240.0;
```

CRITICAL: Do NOT modify any other functions in overlay.rs. The health check system, try_show_overlay, hide_recording_overlay, emit_levels, and ensure_overlay_exists must remain unchanged.
  </action>
  <verify>
1. Verify `use enigo::{Enigo, Mouse};` import exists at top of overlay.rs
2. Run `cargo check --manifest-path src-tauri/Cargo.toml` - no compilation errors
3. Run `cargo clippy --manifest-path src-tauri/Cargo.toml` - no warnings about unused variables or unreachable patterns

Then run `bun run tauri dev` and:
4. With overlay_position set to "top" - overlay appears at top center
5. With overlay_position set to "bottom" - overlay appears at bottom center
6. (Manual test in Plan 03) With "followcursor" - overlay appears near cursor
  </verify>
  <done>
calculate_overlay_position() handles FollowCursor mode with cursor-relative positioning, screen bounds clamping, and fallback behavior. Constants updated to match new CSS dimensions.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cargo check --manifest-path src-tauri/Cargo.toml` passes
2. `cargo clippy --manifest-path src-tauri/Cargo.toml` has no errors
3. `bun run tauri dev` starts successfully
4. Overlay still appears at configured position (top/bottom)
5. No panic or crash when FollowCursor is set in settings
</verification>

<success_criteria>
- OverlayPosition::FollowCursor compiles without errors
- Cursor position clamped within work_area bounds
- Fallback to bottom-center when cursor unavailable
- Existing Top/Bottom/None modes unaffected
- No breaking changes to overlay lifecycle
</success_criteria>

<output>
After completion, create `.planning/phases/01-overlay-redesign/01-02-SUMMARY.md`
</output>
