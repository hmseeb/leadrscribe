---
phase: 08-real-time-transcription-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/managers/streaming_buffer.rs
  - src-tauri/src/managers/mod.rs
  - src-tauri/src/commands/streaming.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "During recording, user sees partial transcription text appear every 2-3 seconds"
    - "Partial text updates smoothly without gaps or stalls"
    - "App does not crash or freeze from GPU memory pressure during streaming"
    - "Streaming results arrive in correct chronological order"
  artifacts:
    - path: "src-tauri/src/managers/streaming_buffer.rs"
      provides: "StreamingBuffer with sliding window overlap management"
      contains: "struct StreamingBuffer"
    - path: "src-tauri/src/commands/streaming.rs"
      provides: "StreamingSession state for managing streaming lifecycle"
      exports: ["StreamingSession", "StreamingTranscriptionEvent"]
  key_links:
    - from: "src-tauri/src/commands/streaming.rs"
      to: "src-tauri/src/managers/streaming_buffer.rs"
      via: "StreamingSession contains a StreamingBuffer"
      pattern: "StreamingBuffer"
    - from: "src-tauri/src/lib.rs"
      to: "src-tauri/src/commands/streaming.rs"
      via: "StreamingSession managed as Tauri state"
      pattern: "StreamingSession"
---

<objective>
Build the backend streaming transcription infrastructure: a StreamingBuffer that accumulates VAD audio segments into 2-3 second chunks with overlap, and a StreamingSession managed state that orchestrates the streaming lifecycle.

Purpose: This is the core backend infrastructure that enables real-time transcription display. Without it, there is no way to get progressive text results during recording.

Output: Two new Rust modules (streaming_buffer.rs and streaming session state) registered in the app.
</objective>

<execution_context>
@C:\Users\hsbaz\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hsbaz\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-real-time-transcription-display/08-RESEARCH.md

Key existing code to reference:
@src-tauri/src/managers/transcription.rs - TranscriptionManager with transcribe() and transcribe_segment_async()
@src-tauri/src/managers/audio.rs - AudioSegmentEvent struct, VAD segment callback
@src-tauri/src/actions.rs - Existing StreamingState (currently disabled), segment listener pattern
@src-tauri/src/commands/mod.rs - Command module structure
@src-tauri/src/lib.rs - invoke_handler registration pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StreamingBuffer module</name>
  <files>src-tauri/src/managers/streaming_buffer.rs, src-tauri/src/managers/mod.rs</files>
  <action>
Create `src-tauri/src/managers/streaming_buffer.rs` implementing a sliding window buffer for audio chunk management.

The StreamingBuffer must:
1. Accept audio segments (Vec<f32>) from VAD callbacks
2. Accumulate samples until reaching a configurable chunk threshold (default 2.5 seconds = 40000 samples at 16kHz)
3. When threshold reached, return a chunk that includes overlap from previous chunk (default 300ms = 4800 samples)
4. Track chunk index for ordering
5. Provide reset() to clear state between recordings
6. Be thread-safe (wrap internals in Arc<Mutex<>>)

Constants to define:
```rust
const SAMPLE_RATE: usize = 16000;
const CHUNK_DURATION_MS: usize = 2500;     // 2.5 second chunks
const OVERLAP_MS: usize = 300;             // 300ms overlap
const MIN_CHUNK_SAMPLES: usize = (CHUNK_DURATION_MS * SAMPLE_RATE) / 1000;  // 40000
const OVERLAP_SAMPLES: usize = (OVERLAP_MS * SAMPLE_RATE) / 1000;           // 4800
```

Struct design:
```rust
pub struct StreamingBuffer {
    buffer: Vec<f32>,           // Accumulated samples not yet emitted as a chunk
    overlap: Vec<f32>,          // Tail of last emitted chunk for overlap
    chunk_index: usize,         // Next chunk index
}

impl StreamingBuffer {
    pub fn new() -> Self { ... }

    /// Add audio segment samples. Returns Some(chunk, chunk_index) if threshold reached.
    pub fn add_segment(&mut self, samples: Vec<f32>) -> Option<(Vec<f32>, usize)> {
        // 1. Append samples to buffer
        // 2. Check if buffer >= MIN_CHUNK_SAMPLES
        // 3. If yes: build chunk = overlap + buffer, save new overlap from tail,
        //    clear buffer, increment chunk_index, return chunk
        // 4. If no: return None
    }

    /// Flush any remaining samples as a final chunk (called when recording stops)
    pub fn flush(&mut self) -> Option<(Vec<f32>, usize)> {
        // Return remaining buffer + overlap if buffer has meaningful audio (> 0.5s)
        // Minimum flush size: 8000 samples (0.5s) to avoid hallucinations
    }

    /// Reset for new recording session
    pub fn reset(&mut self) {
        self.buffer.clear();
        self.overlap.clear();
        self.chunk_index = 0;
    }

    pub fn current_chunk_index(&self) -> usize { self.chunk_index }
}
```

IMPORTANT: Do NOT use a ring buffer crate. The Vec-based approach is simpler and sufficient for this use case since we process chunks sequentially, not in a real-time audio callback. The research recommended direct_ring_buffer, but the actual pattern here is simpler - we accumulate and drain.

Add `pub mod streaming_buffer;` to `src-tauri/src/managers/mod.rs`.
  </action>
  <verify>
Run `cd C:\Users\hsbaz\leadrscribe && cargo check --manifest-path src-tauri/Cargo.toml 2>&1 | head -20` to verify compilation. The module should compile without errors.
  </verify>
  <done>StreamingBuffer struct exists with add_segment(), flush(), and reset() methods. Module is registered in managers/mod.rs. cargo check passes.</done>
</task>

<task type="auto">
  <name>Task 2: Create StreamingSession managed state</name>
  <files>src-tauri/src/commands/streaming.rs, src-tauri/src/commands/mod.rs, src-tauri/src/lib.rs</files>
  <action>
Create `src-tauri/src/commands/streaming.rs` with the StreamingSession state and event types. This plan does NOT create Tauri commands (no Channel-based invoke commands needed). Instead, it provides the managed state that actions.rs will use directly in Plan 03.

Define the streaming event type (used by actions.rs to emit to the transcription display window):
```rust
use serde::Serialize;
use std::sync::Mutex;
use crate::managers::streaming_buffer::StreamingBuffer;

#[derive(Clone, Serialize)]
#[serde(tag = "type")]
pub enum StreamingTranscriptionEvent {
    Partial { text: String, chunk_index: usize },
    Final { text: String },
    Error { message: String },
}
```

Note on serde tagging: Use `#[serde(tag = "type")]` so the frontend receives `{ type: "Partial", text: "...", chunk_index: 0 }` which is easier to discriminate in TypeScript than Rust-style `{ Partial: { text: "...", chunk_index: 0 } }`.

Create the managed state struct:
```rust
pub struct StreamingSession {
    pub buffer: Mutex<StreamingBuffer>,
    pub is_active: Mutex<bool>,
    pub partial_texts: Mutex<Vec<String>>,     // Indexed by chunk_index
    pub pending_chunks: std::sync::atomic::AtomicUsize,  // Track in-flight transcriptions
}

impl StreamingSession {
    pub fn new() -> Self {
        Self {
            buffer: Mutex::new(StreamingBuffer::new()),
            is_active: Mutex::new(false),
            partial_texts: Mutex::new(Vec::new()),
            pending_chunks: std::sync::atomic::AtomicUsize::new(0),
        }
    }
}
```

Register the StreamingSession as managed state in `src-tauri/src/lib.rs`:
- Add `use crate::managers::streaming_buffer::StreamingBuffer;`
- Add `use crate::commands::streaming::StreamingSession;`
- After other manager initializations: `app_handle.manage(Arc::new(StreamingSession::new()));`

Add `pub mod streaming;` to `src-tauri/src/commands/mod.rs`.

IMPORTANT: Do NOT create Tauri Channel-based commands (start_streaming_transcription, stop_streaming_transcription). The streaming lifecycle is managed directly from Rust in actions.rs (Plan 03), not invoked from the frontend. Events are sent to the transcription display window using window-targeted `window.emit()` which is sufficient for the low throughput (one event every 2-3 seconds per chunk).

AVOID: Do NOT modify the existing batch transcription flow in actions.rs yet. This plan only creates the streaming infrastructure. Plan 03 will integrate it into the recording flow.
  </action>
  <verify>
Run `cd C:\Users\hsbaz\leadrscribe && cargo check --manifest-path src-tauri/Cargo.toml 2>&1 | head -30` to verify compilation. The managed state should compile and be registered.
  </verify>
  <done>StreamingSession managed state exists with buffer, is_active, partial_texts, pending_chunks fields. StreamingTranscriptionEvent enum defined with Partial/Final/Error variants. StreamingSession is managed in lib.rs. cargo check passes with no errors.</done>
</task>

</tasks>

<verification>
1. `cargo check --manifest-path src-tauri/Cargo.toml` passes with no errors
2. `streaming_buffer.rs` contains StreamingBuffer with add_segment, flush, reset methods
3. `commands/streaming.rs` contains StreamingSession state and StreamingTranscriptionEvent enum
4. StreamingSession is managed in lib.rs
5. No Tauri Channel commands created (streaming uses window-targeted events, not Channels)
</verification>

<success_criteria>
- Backend streaming infrastructure compiles and is registered with Tauri
- StreamingBuffer correctly accumulates segments with overlap management
- StreamingSession provides thread-safe state for streaming lifecycle
- StreamingTranscriptionEvent typed with Partial/Final/Error variants
- No modifications to existing batch transcription flow
</success_criteria>

<output>
After completion, create `.planning/phases/08-real-time-transcription-display/08-01-SUMMARY.md`
</output>
