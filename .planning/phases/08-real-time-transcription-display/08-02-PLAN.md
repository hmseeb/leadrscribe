---
phase: 08-real-time-transcription-display
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/overlay/TranscriptionDisplay.tsx
  - src/overlay/transcription-display.html
  - src/overlay/transcription-display-main.tsx
  - src/index.css
autonomous: true

must_haves:
  truths:
    - "Transcription display is a dark translucent bar with rounded corners"
    - "Text appears with word-by-word fade-in animation"
    - "Display auto-scrolls as new text arrives"
    - "Pulse indicator on left shows active listening state"
    - "Clicking the display dismisses it"
  artifacts:
    - path: "src/overlay/TranscriptionDisplay.tsx"
      provides: "React component for real-time transcription text display"
      min_lines: 80
    - path: "src/overlay/transcription-display.html"
      provides: "HTML entry point for transcription display window"
      contains: "transcription-display-main.tsx"
    - path: "src/overlay/transcription-display-main.tsx"
      provides: "React mount point for transcription display"
      contains: "TranscriptionDisplay"
  key_links:
    - from: "src/overlay/TranscriptionDisplay.tsx"
      to: "framer-motion"
      via: "Word-by-word reveal animation using motion.span"
      pattern: "motion\\.span"
    - from: "src/overlay/transcription-display-main.tsx"
      to: "src/overlay/TranscriptionDisplay.tsx"
      via: "Imports and renders TranscriptionDisplay"
      pattern: "TranscriptionDisplay"
---

<objective>
Create the frontend transcription display overlay component - a dark translucent bar that shows real-time transcription text with word-by-word animations, auto-scroll, and a listening pulse indicator.

Purpose: This is the visual component users see during dictation. It runs in a separate Tauri window above the recording overlay pill.

Output: TranscriptionDisplay React component with its HTML entry point and mount file, plus CSS styles.
</objective>

<execution_context>
@C:\Users\hsbaz\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\hsbaz\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-real-time-transcription-display/08-RESEARCH.md

Key existing code to reference:
@src/overlay/RecordingOverlay.tsx - Existing overlay pattern (event listeners, animation, theme)
@src/overlay/main.tsx - Mount pattern with theme initialization
@src/overlay/index.html - HTML entry point pattern for overlay windows
@src/index.css - Existing styles including overlay CSS
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TranscriptionDisplay component and entry files</name>
  <files>src/overlay/TranscriptionDisplay.tsx, src/overlay/transcription-display.html, src/overlay/transcription-display-main.tsx</files>
  <action>
Create three files for the transcription display overlay window:

**1. `src/overlay/transcription-display.html`**
Follow the exact pattern from `src/overlay/index.html`:
- Same head structure (charset, fonts)
- Body with class `overlay-window`, transparent background, overflow hidden
- Root div with transparent background
- Script tag pointing to `transcription-display-main.tsx`

**2. `src/overlay/transcription-display-main.tsx`**
Follow the exact pattern from `src/overlay/main.tsx`:
- Same theme initialization (getSystemTheme, getEffectiveTheme, applyTheme)
- Same theme listener setup (listen for "theme-changed", system preference changes)
- Render `<TranscriptionDisplay />` into root
- Import `../index.css`

**3. `src/overlay/TranscriptionDisplay.tsx`**
Create the main component with these features:

**State management:**
```typescript
const [isVisible, setIsVisible] = useState(false);
const [words, setWords] = useState<string[]>([]);         // Array of words for animation
const [isListening, setIsListening] = useState(false);     // Pulse indicator state
const scrollRef = useRef<HTMLDivElement>(null);
const [shouldAutoScroll, setShouldAutoScroll] = useState(true);
```

**Event listeners (use Tauri window-targeted events -- Plan 03 wires the backend to emit these):**
- Listen for `"show-transcription-display"` -> setIsVisible(true), setIsListening(true)
- Listen for `"hide-transcription-display"` -> fade out, then setIsVisible(false)
- Listen for `"transcription-partial"` with payload `{ text: string, chunk_index: number }` -> parse text into words, append to words array
- Listen for `"transcription-final"` with payload `{ text: string }` -> replace all words with final text words
- Listen for `"transcription-clear"` -> clear words, reset state

**Word-by-word animation using Framer Motion:**
Use AnimatePresence and staggerChildren pattern from research:
```tsx
const wordVariants = {
  hidden: { opacity: 0, y: 8 },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      type: "spring",
      stiffness: 500,
      damping: 30,
    }
  }
};

// Track which words are "new" (just added) vs already visible
// Use a ref to track the previous word count
const prevWordCountRef = useRef(0);

// Render:
<div className="transcription-words" ref={scrollRef}>
  {words.map((word, i) => (
    <motion.span
      key={`${i}-${word}`}
      initial={i >= prevWordCountRef.current ? "hidden" : false}
      animate="visible"
      variants={wordVariants}
      className="transcription-word"
    >
      {word}{' '}
    </motion.span>
  ))}
</div>
```

After rendering, update prevWordCountRef.current = words.length.

**Auto-scroll:**
```tsx
useEffect(() => {
  if (shouldAutoScroll && scrollRef.current) {
    requestAnimationFrame(() => {
      scrollRef.current?.scrollTo({
        top: scrollRef.current.scrollHeight,
        behavior: 'smooth'
      });
    });
  }
}, [words, shouldAutoScroll]);
```

Detect if user scrolled up (disable auto-scroll):
```tsx
const handleScroll = () => {
  if (!scrollRef.current) return;
  const { scrollTop, scrollHeight, clientHeight } = scrollRef.current;
  setShouldAutoScroll(scrollHeight - scrollTop - clientHeight < 50);
};
```

**Pulse indicator (left side):**
A small animated circle/waveform that pulses when isListening is true:
```tsx
<motion.div
  className="listening-indicator"
  animate={isListening ? {
    scale: [1, 1.3, 1],
    opacity: [0.6, 1, 0.6],
  } : { scale: 1, opacity: 0.3 }}
  transition={{
    duration: 1.5,
    repeat: Infinity,
    ease: "easeInOut",
  }}
/>
```

**Click to dismiss:**
Add onClick handler on the outer container that hides the window. Use `getCurrentWindow().hide()` from `@tauri-apps/api/window`.

**Layout structure:**
```tsx
<div className="transcription-display-container">
  <AnimatePresence>
    {isVisible && (
      <motion.div
        className="transcription-display"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: 20 }}
        transition={{ type: "spring", stiffness: 300, damping: 25 }}
        onClick={handleDismiss}
      >
        <div className="transcription-display-left">
          {/* Pulse indicator */}
        </div>
        <div className="transcription-display-content" ref={scrollRef} onScroll={handleScroll}>
          {/* Word-by-word text */}
          {words.length === 0 && (
            <span className="transcription-placeholder">Listening...</span>
          )}
        </div>
      </motion.div>
    )}
  </AnimatePresence>
</div>
```

Use imports from the same libraries as RecordingOverlay.tsx:
- `import { invoke } from "@tauri-apps/api/core";`
- `import { listen } from "@tauri-apps/api/event";`
- `import { getCurrentWindow } from "@tauri-apps/api/window";`
- `import { motion, AnimatePresence } from "framer-motion";`
  </action>
  <verify>
Run `cd C:\Users\hsbaz\leadrscribe && npx tsc --noEmit 2>&1 | head -20` to check for TypeScript errors. If tsc is not directly available, run `bun run build 2>&1 | head -30` to check the Vite build.
  </verify>
  <done>TranscriptionDisplay.tsx component exists with word-by-word animation, auto-scroll, pulse indicator, and click-to-dismiss. Entry HTML and mount files follow the exact same pattern as the existing recording overlay. TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add transcription display CSS styles</name>
  <files>src/index.css</files>
  <action>
Add CSS styles for the transcription display overlay to `src/index.css`. Place them near the existing `.recording-overlay` styles (search for "recording-overlay" to find the right location).

Design specs from the roadmap:
- Dark translucent bar: 85% opacity black, rounded corners
- Width: 600px, max-height: 200px (scrollable)
- Positioned to fill the transcription display window (the Rust backend will position the window itself)

Add these styles:

```css
/* Transcription Display Overlay */
.transcription-display-container {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
}

.transcription-display {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  width: 100%;
  max-height: 100%;
  padding: 16px 20px;
  background: oklch(0.12 0 0 / 0.85);
  border-radius: 16px;
  border: 1px solid oklch(1 0 0 / 0.06);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  box-shadow: 0 8px 32px oklch(0 0 0 / 0.4);
  cursor: pointer;
  user-select: none;
  overflow: hidden;
}

.transcription-display-left {
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  padding-top: 2px;
}

.listening-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: oklch(0.72 0.19 155);  /* Green pulse dot */
}

.transcription-display-content {
  flex: 1;
  overflow-y: auto;
  max-height: 160px;
  line-height: 1.6;
  scrollbar-width: thin;
  scrollbar-color: oklch(1 0 0 / 0.15) transparent;
}

.transcription-display-content::-webkit-scrollbar {
  width: 4px;
}

.transcription-display-content::-webkit-scrollbar-track {
  background: transparent;
}

.transcription-display-content::-webkit-scrollbar-thumb {
  background: oklch(1 0 0 / 0.15);
  border-radius: 2px;
}

.transcription-word {
  display: inline;
  color: oklch(0.95 0 0);
  font-size: 14px;
  font-weight: 400;
  font-family: 'DM Sans', sans-serif;
}

.transcription-placeholder {
  color: oklch(0.6 0 0);
  font-size: 14px;
  font-style: italic;
  font-family: 'DM Sans', sans-serif;
}
```

For light theme support, add light-mode overrides only if the existing pattern uses `.light` or absence of `.dark`:
```css
/* Light theme is not needed for the transcription display - it always uses dark theme
   because it's a floating overlay that should be dark regardless of app theme setting.
   This matches the recording overlay behavior. */
```

IMPORTANT: The transcription display ALWAYS uses the dark theme (matching the recording overlay pill). Do NOT add light theme variants.

AVOID: Do not modify any existing recording-overlay styles. Only add new styles.
  </action>
  <verify>
Run `cd C:\Users\hsbaz\leadrscribe && bun run build 2>&1 | tail -5` to verify the frontend builds successfully with the new styles.
  </verify>
  <done>CSS styles for transcription display exist in index.css: dark translucent bar (85% opacity), rounded corners, word text styling, listening indicator, scrollable content area, placeholder text. Frontend builds without errors.</done>
</task>

</tasks>

<verification>
1. `bun run build` completes without TypeScript or CSS errors
2. TranscriptionDisplay.tsx contains word-by-word Framer Motion animation
3. transcription-display.html and transcription-display-main.tsx follow existing overlay patterns
4. CSS styles define dark translucent bar with 85% opacity, rounded corners
5. No existing styles or components modified
</verification>

<success_criteria>
- TranscriptionDisplay component renders a dark translucent bar with word animation
- HTML entry point and React mount file follow existing overlay window pattern
- Pulse indicator animates when listening
- Auto-scroll works as text grows
- Click-to-dismiss functionality exists
- All styles are dark theme only (matches overlay philosophy)
- Frontend builds cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/08-real-time-transcription-display/08-02-SUMMARY.md`
</output>
