---
phase: 10-security-code-health
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/settings.rs
  - src-tauri/tauri.conf.json
  - src-tauri/src/managers/history.rs
autonomous: true

must_haves:
  truths:
    - OpenRouter API key no longer stored in plaintext settings file
    - API key auto-migrates from settings to keychain on first launch
    - Content Security Policy blocks inline scripts and restricts external resources
    - Asset protocol can only access app data and resources directories
    - SQL queries use safe patterns with documented rationale
  artifacts:
    - path: src-tauri/Cargo.toml
      provides: keyring crate dependency
      contains: 'keyring = "'
    - path: src-tauri/src/settings.rs
      provides: Keychain-backed API key storage with migration
      min_lines: 200
    - path: src-tauri/tauri.conf.json
      provides: Restrictive CSP and asset protocol scope
      contains: '"csp":'
  key_links:
    - from: src-tauri/src/settings.rs
      to: keyring crate
      via: Keychain read/write/delete operations
      pattern: 'keyring::(Entry|Credential)'
    - from: src-tauri/src/settings.rs
      to: settings_store.json
      via: Migration reads old key, saves to keychain, removes from file
      pattern: 'openrouter_api_key'
---

<objective>
Harden application security by securing API key storage, enforcing Content Security Policy, restricting asset protocol scope, and documenting SQL safety.

Purpose: Address 4 security audit findings (SEC-01 through SEC-04) that expose sensitive data or create attack surface
Output: Production-ready security hardening with zero plaintext credentials and restrictive CSP/asset policies
</objective>

<execution_context>
@C:/Users/hsbaz/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hsbaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/hsbaz/leadrscribe/.planning/PROJECT.md
@C:/Users/hsbaz/leadrscribe/.planning/ROADMAP.md
@C:/Users/hsbaz/leadrscribe/.planning/STATE.md
@C:/Users/hsbaz/leadrscribe/.planning/codebase/STACK.md
@C:/Users/hsbaz/leadrscribe/.planning/codebase/ARCHITECTURE.md
@C:/Users/hsbaz/leadrscribe/.planning/codebase/CONVENTIONS.md

@C:/Users/hsbaz/leadrscribe/src-tauri/src/settings.rs
@C:/Users/hsbaz/leadrscribe/src-tauri/tauri.conf.json
@C:/Users/hsbaz/leadrscribe/src-tauri/src/managers/history.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Move OpenRouter API key to OS keychain with auto-migration</name>
  <files>src-tauri/Cargo.toml, src-tauri/src/settings.rs</files>
  <action>
**Add keyring dependency:**
Add to `src-tauri/Cargo.toml` dependencies section:
```toml
keyring = "3.8.0"
```

**Implement keychain storage in settings.rs:**

1. Remove `openrouter_api_key: Option<String>` from `Settings` struct (line 184)
2. Add keyring service constant: `const KEYRING_SERVICE: &str = "com.leadr.leadrscribe";`
3. Add keyring username constant: `const KEYRING_USER: &str = "openrouter_api_key";`

4. Create keychain helper functions:
```rust
use keyring::Entry;

fn get_keyring_entry() -> Result<Entry, String> {
    Entry::new(KEYRING_SERVICE, KEYRING_USER)
        .map_err(|e| format!("Failed to access keyring: {}", e))
}

pub fn get_openrouter_api_key() -> Option<String> {
    match get_keyring_entry() {
        Ok(entry) => entry.get_password().ok(),
        Err(_) => None,
    }
}

pub fn set_openrouter_api_key(key: &str) -> Result<(), String> {
    let entry = get_keyring_entry()?;
    entry.set_password(key)
        .map_err(|e| format!("Failed to save API key: {}", e))
}

pub fn delete_openrouter_api_key() -> Result<(), String> {
    let entry = get_keyring_entry()?;
    entry.delete_credential()
        .map_err(|e| format!("Failed to delete API key: {}", e))
}
```

5. Add migration logic to `get_settings()` function (after settings load, before return):
```rust
// Migrate API key from settings file to keychain (one-time migration)
if let Some(plaintext_key) = settings.openrouter_api_key.take() {
    // Save to keychain
    if let Err(e) = set_openrouter_api_key(&plaintext_key) {
        log::warn!("Failed to migrate API key to keychain: {}", e);
        // Keep in settings as fallback
        settings.openrouter_api_key = Some(plaintext_key);
    } else {
        // Successfully migrated - remove from settings file
        if let Err(e) = save_settings(app_handle, &settings) {
            log::warn!("Failed to save settings after migration: {}", e);
        }
        log::info!("Migrated OpenRouter API key to OS keychain");
    }
}
```

6. Update any code reading `settings.openrouter_api_key` to call `get_openrouter_api_key()` instead
7. Update any code writing API key to call `set_openrouter_api_key()` instead

**Rationale:** OS keychain (Windows Credential Manager, macOS Keychain, Linux Secret Service) provides encrypted storage with OS-level access control. Auto-migration ensures existing users don't lose their API keys.
  </action>
  <verify>
Run `cargo build` - must compile successfully.
Check that `keyring` crate is in Cargo.toml dependencies.
Grep for `openrouter_api_key` in settings.rs - should only appear in migration code and old struct definition removal.
  </verify>
  <done>
API key storage uses OS keychain via keyring crate.
Migration code reads plaintext key from settings, saves to keychain, removes from settings file.
No compilation errors related to API key access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Set restrictive CSP and narrow asset protocol scope</name>
  <files>src-tauri/tauri.conf.json</files>
  <action>
**Fix Content Security Policy (line 29):**

Change from:
```json
"csp": null,
```

To:
```json
"csp": "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https://openrouter.ai;",
```

**Rationale:**
- `default-src 'self'`: Only load resources from app origin
- `script-src 'self'`: Block inline scripts and eval (XSS protection)
- `style-src 'self' 'unsafe-inline'`: Allow Tailwind CSS inline styles (required for component styling)
- `img-src 'self' data: https:`: Allow images from app, data URIs, and HTTPS (for model thumbnails if added later)
- `font-src 'self' data:`: Allow fonts from app and data URIs
- `connect-src 'self' https://openrouter.ai`: Allow API calls to OpenRouter only (Ghostwriter feature)

**Narrow asset protocol scope (lines 32-34):**

Change from:
```json
"scope": {
  "allow": ["**"],
  "requireLiteralLeadingDot": false
}
```

To:
```json
"scope": {
  "allow": ["$APPDATA/**", "$RESOURCE/**"],
  "requireLiteralLeadingDot": false
}
```

**Rationale:**
- `$APPDATA`: App data directory (settings, models, history database)
- `$RESOURCE`: Resources directory (bundled VAD model, audio feedback sounds)
- Removes `**` wildcard that allowed reading any file on the filesystem
- Follows principle of least privilege - only access what's needed
  </action>
  <verify>
Run `bun run tauri build` - frontend must build successfully.
Check tauri.conf.json line 29 has CSP string (not null).
Check tauri.conf.json line 33 has `["$APPDATA/**", "$RESOURCE/**"]` (not `["**"]`).
  </verify>
  <done>
CSP is set to restrictive policy blocking inline scripts.
Asset protocol scope limited to app data and resources directories.
Application builds without CSP or asset protocol errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Document SQL safety in history migration</name>
  <files>src-tauri/src/managers/history.rs</files>
  <action>
**Add safety documentation to `has_column` closure (lines 283-288):**

Add comment above the closure explaining why `format!()` is safe here:

```rust
// SAFETY: SQL injection prevention
// The `has_column` closure uses format!() to build SQL queries, which is normally
// a SQL injection risk. However, in this context it is safe because:
// 1. `table` parameter is hardcoded as "transcriptions" (line 281) - developer-controlled
// 2. `column` parameter is always a hardcoded string literal from migration logic - developer-controlled
// 3. No user input flows into these queries
// 4. This is migration-only code, not a general-purpose query function
//
// If this function is ever modified to accept user input, it MUST be refactored
// to use parameterized queries via rusqlite's `?` placeholders.
let has_column = |table: &str, column: &str| -> bool {
    let query = format!("PRAGMA table_info({})", table);
    // ... rest of closure
};
```

**Verification:** No code changes needed - this is documentation only. The pattern is already safe but lacks documentation explaining why.
  </action>
  <verify>
Read src-tauri/src/managers/history.rs lines 280-290.
Verify safety comment is present above `has_column` closure.
Comment must explain why format!() is safe (developer-controlled inputs, no user data).
  </verify>
  <done>
SQL format string usage is documented with safety rationale.
Comment explicitly warns against accepting user input without parameterized queries.
Future maintainers understand why this pattern is acceptable here.
  </done>
</task>

</tasks>

<verification>
**Build verification:**
- `cd src-tauri && cargo build` - compiles successfully
- `bun run tauri build` - frontend builds successfully

**Security verification:**
- No `openrouter_api_key` in settings_store.json after migration runs
- `keyring` crate listed in Cargo.toml dependencies
- CSP in tauri.conf.json is restrictive string (not null)
- Asset protocol scope uses `$APPDATA` and `$RESOURCE` (not `**`)
- SQL safety comment present in history.rs

**Pattern matching:**
- `grep 'keyring' src-tauri/Cargo.toml` - finds dependency
- `grep 'get_openrouter_api_key' src-tauri/src/settings.rs` - finds function
- `grep '"csp":' src-tauri/tauri.conf.json` - finds CSP policy
- `grep 'SAFETY:' src-tauri/src/managers/history.rs` - finds SQL safety comment
</verification>

<success_criteria>
**Security improvements measurable:**
- OpenRouter API key stored in OS keychain (Windows Credential Manager / macOS Keychain / Linux Secret Service)
- Existing plaintext API keys auto-migrate to keychain on first app launch
- Content Security Policy blocks inline scripts and restricts resource loading
- Asset protocol scope limited to app data and resources directories (not entire filesystem)
- SQL format string usage documented with safety rationale

**All 4 security audit findings (SEC-01 through SEC-04) resolved:**
- ✅ SEC-01: API key in keychain (not plaintext)
- ✅ SEC-02: CSP set (not null)
- ✅ SEC-03: Asset protocol scoped (not `**`)
- ✅ SEC-04: SQL safety documented

**Zero regressions:**
- Application builds successfully
- Ghostwriter feature works with keychain-backed API key
- No CSP violations in dev console
- Settings and model loading still work (asset protocol scope correct)
</success_criteria>

<output>
After completion, create `.planning/phases/10-security-code-health/10-01-SUMMARY.md` following the summary template format.
</output>
