---
phase: 10-security-code-health
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/actions.rs
  - src-tauri/src/managers/transcription.rs
  - src-tauri/src/managers/model.rs
  - src-tauri/src/ghostwriter.rs
  - src-tauri/src/settings.rs
  - src-tauri/src/lib.rs
  - src-tauri/src/shortcut.rs
  - src-tauri/src/utils.rs
  - src-tauri/src/managers/audio.rs
  - src-tauri/src/commands/models.rs
  - src-tauri/src/commands/audio.rs
  - src-tauri/src/audio_feedback.rs
autonomous: true

must_haves:
  truths:
    - No diagnostic println! statements remain in production code
    - All diagnostic output uses log crate macros (debug!, info!, warn!, error!)
    - Error output still uses eprintln! (stderr for actual errors is acceptable)
    - Log statements provide context for debugging without console pollution
  artifacts:
    - path: src-tauri/src/actions.rs
      provides: debug! macros for state transitions
      not_contains: 'println!("'
    - path: src-tauri/src/managers/transcription.rs
      provides: debug! macros for transcription flow
      not_contains: 'println!("'
    - path: src-tauri/src/managers/model.rs
      provides: info! and debug! macros for model operations
      not_contains: 'println!("'
    - path: src-tauri/src/ghostwriter.rs
      provides: debug! macros for API communication
      not_contains: 'println!("'
  key_links:
    - from: All modified files
      to: log crate
      via: debug!/info!/warn!/error! macro usage
      pattern: '(debug|info|warn|error)!\('
---

<objective>
Replace all diagnostic println! statements with proper log crate macros for production-ready logging.

Purpose: Address code health audit finding (HLTH-03) - excessive println! debugging that pollutes console output and lacks log level control
Output: Clean logging using debug!/info!/warn!/error! macros with appropriate log levels for each message
</objective>

<execution_context>
@C:/Users/hsbaz/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hsbaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/Users/hsbaz/leadrscribe/.planning/PROJECT.md
@C:/Users/hsbaz/leadrscribe/.planning/ROADMAP.md
@C:/Users/hsbaz/leadrscribe/.planning/STATE.md
@C:/Users/hsbaz/leadrscribe/.planning/codebase/CONVENTIONS.md

@C:/Users/hsbaz/leadrscribe/src-tauri/src/actions.rs
@C:/Users/hsbaz/leadrscribe/src-tauri/src/managers/transcription.rs
@C:/Users/hsbaz/leadrscribe/src-tauri/src/managers/model.rs
@C:/Users/hsbaz/leadrscribe/src-tauri/src/ghostwriter.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace println! with log macros in core modules</name>
  <files>src-tauri/src/actions.rs, src-tauri/src/managers/transcription.rs, src-tauri/src/managers/model.rs, src-tauri/src/ghostwriter.rs</files>
  <action>
**Logging level guidelines:**
- `debug!()` - Detailed diagnostic info (state dumps, variable values, flow tracing)
- `info!()` - Important events (model loaded, recording started, API calls)
- `warn!()` - Unexpected but recoverable conditions
- `error!()` - Actual errors (keep existing eprintln! for errors, or convert to error!())

**actions.rs (lines 130-133, 144, 155, 158, 159, 291):**

Replace diagnostic println! with debug!():
- Line 130-133: State transition dumps → `debug!("Action '{}' completed. New state: ...", action_name);`
- Line 144, 155, 158, 159: Streaming state updates → `debug!("Streaming text updated: {}", partial_text);`
- Line 291: Action execution → `debug!("Executing action: {}", action_name);`

**managers/transcription.rs (lines 358, 445, 452):**

- Line 358: Transcription timing → `info!("Transcription completed in {:.2}s", elapsed.as_secs_f32());`
- Line 445: VAD segment info → `debug!("Processing audio segment: {} samples", samples.len());`
- Line 452: Model inference → `debug!("Running inference with model: {}", model_id);`

**managers/model.rs (many println! statements):**

Review each println! and convert based on content:
- Model download progress → `info!("Downloading model: {} ({:.1}%)", model_name, progress);`
- Model loading → `info!("Loading model: {}", model_path);`
- Cache hits → `debug!("Model {} already loaded", model_id);`
- File operations → `debug!("Writing model to: {}", path);`
- Extraction progress → `debug!("Extracting {} bytes", size);`

**ghostwriter.rs (lines 359-406):**

All println! in API communication logic:
- API request start → `debug!("Sending request to OpenRouter API");`
- Response chunks → `debug!("Received {} bytes from API", chunk.len());`
- Parsed response → `debug!("API response: {:?}", response);`
- Token usage → `info!("API tokens used: {}", usage.total_tokens);`

**Pattern for conversion:**
```rust
// BEFORE
println!("Some debug info: {}", value);

// AFTER
debug!("Some debug info: {}", value);
```

**DO NOT change:**
- `eprintln!()` for actual errors - stderr output is correct
- Test code println! (if any) - acceptable in tests
- CLI tool println! in `audio_toolkit/bin/cli.rs` - CLI output is intentional
  </action>
  <verify>
Run `cargo build` - must compile successfully.
Grep for `println!` in modified files - should find ZERO matches (except in comments).
Grep for `debug!` in modified files - should find NEW matches.
Grep for `info!` in modified files - should find NEW matches.
  </verify>
  <done>
All diagnostic println! in core modules replaced with debug!/info! macros.
Log statements use appropriate levels (debug for diagnostics, info for events).
Error output still uses eprintln! or error! macro.
Code compiles without warnings about println! usage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace println! with log macros in remaining modules</name>
  <files>src-tauri/src/settings.rs, src-tauri/src/lib.rs, src-tauri/src/shortcut.rs, src-tauri/src/utils.rs, src-tauri/src/managers/audio.rs, src-tauri/src/commands/models.rs, src-tauri/src/commands/audio.rs, src-tauri/src/audio_feedback.rs</files>
  <action>
Apply same conversion pattern to remaining files with println! statements:

**settings.rs:**
- Settings load/save → `debug!("Loaded settings: {:?}", settings);`
- Migration → `info!("Migrated setting: {}", setting_name);`

**lib.rs:**
- App initialization → `info!("Initializing LeadrScribe v{}", version);`
- Manager setup → `debug!("Created manager: {}", manager_name);`

**shortcut.rs:**
- Shortcut registration → `info!("Registered shortcut: {}", key_combination);`
- Health check → `debug!("Shortcut health check passed");`

**utils.rs:**
- Overlay creation → `debug!("Creating overlay window at position: {:?}", position);`
- Tray updates → `debug!("Updated tray menu");`

**managers/audio.rs:**
- Device enumeration → `debug!("Found {} audio devices", count);`
- Device selection → `info!("Selected audio device: {}", device_name);`

**commands/models.rs:**
- Model queries → `debug!("Querying available models");`
- Model status → `debug!("Model {} status: {}", model_id, status);`

**commands/audio.rs:**
- Audio command execution → `debug!("Audio command: {}", command_name);`

**audio_feedback.rs:**
- Sound playback → `debug!("Playing audio feedback: {}", sound_name);`

**Ensure log crate is imported:**
Add `use log::{debug, info, warn, error};` at top of each modified file if not already present.

**Exception for CLI tool:**
DO NOT modify `src-tauri/src/audio_toolkit/bin/cli.rs` - this is a command-line tool where println! is the correct output method (not logging).

**Verification pattern:**
After changes, run:
```bash
grep -r 'println!' src-tauri/src/ --include='*.rs' --exclude-dir=audio_toolkit/bin
```
Should return ZERO matches in production code (excluding CLI bin).
  </action>
  <verify>
Run `cargo build` - must compile successfully.
Grep for `println!` in src-tauri/src/ (excluding audio_toolkit/bin) - should find ZERO matches.
Grep for `use log::` imports in modified files - should find matches.
All modified files use debug!/info!/warn!/error! instead of println!.
  </verify>
  <done>
All production code println! replaced with appropriate log macros.
CLI tool (audio_toolkit/bin/cli.rs) unchanged (println! is correct for CLI output).
Log crate imported in all modified files.
No compilation errors from logging changes.
  </done>
</task>

</tasks>

<verification>
**Build verification:**
- `cd src-tauri && cargo build` - compiles successfully

**Diagnostic println! elimination:**
```bash
# Should find ZERO matches in production code
grep -r 'println!' src-tauri/src/ --include='*.rs' --exclude-dir=bin

# Should find matches (log macros now used)
grep -r 'debug!' src-tauri/src/ --include='*.rs' | wc -l
grep -r 'info!' src-tauri/src/ --include='*.rs' | wc -l
```

**Verify log levels are appropriate:**
- State dumps, variable values → debug!()
- Important events (model loaded, recording started) → info!()
- Errors → error!() or eprintln!()

**No regressions:**
- Application runs and logs to console (env_logger initialized in lib.rs)
- Debug logging can be controlled via RUST_LOG environment variable
- Production builds can disable debug logging for performance
</verification>

<success_criteria>
**Diagnostic println! replaced:**
- Zero println! statements in production code (excluding CLI tool)
- All diagnostic output uses log crate macros
- Appropriate log levels (debug for diagnostics, info for events, error for errors)

**Code health audit finding (HLTH-03) resolved:**
- ✅ HLTH-03: All diagnostic println! replaced with log macros

**Logging benefits:**
- Log level control via RUST_LOG environment variable
- Debug logging can be disabled in production for performance
- Structured logging ready for future log aggregation
- Console output clean and controllable

**Zero regressions:**
- Application compiles successfully
- Logging works correctly (visible in dev console)
- No functionality broken by logging changes
- CLI tool output unchanged (println! still used where appropriate)
</success_criteria>

<output>
After completion, create `.planning/phases/10-security-code-health/10-03-SUMMARY.md` following the summary template format.
</output>
