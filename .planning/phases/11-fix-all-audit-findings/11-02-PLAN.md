---
phase: 11-fix-all-audit-findings
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/overlay/main.tsx
  - src-tauri/src/overlay.rs
  - src-tauri/src/audio_feedback.rs
autonomous: true

must_haves:
  truths:
    - "Overlay theme initializes correctly from Tauri store (not always falling back to system theme)"
    - "emit_levels does NOT read full settings from disk on every audio callback"
    - "play_feedback_sound reads settings exactly once per invocation"
  artifacts:
    - path: "src/overlay/main.tsx"
      provides: "Working theme initialization using Tauri store plugin"
      contains: "plugin-store"
    - path: "src-tauri/src/overlay.rs"
      provides: "Cached overlay position for emit_levels"
      contains: "AtomicU8"
    - path: "src-tauri/src/audio_feedback.rs"
      provides: "Single settings read in play_feedback_sound"
  key_links:
    - from: "src/overlay/main.tsx"
      to: "settings_store.json"
      via: "Tauri store plugin read"
      pattern: "plugin-store"
---

<objective>
Fix overlay theme initialization and eliminate hot-path settings reads in emit_levels and audio feedback.

Purpose: The overlay theme is completely broken (always falls back to system theme). Audio callbacks read the full settings JSON from disk on every invocation, causing unnecessary I/O on a very hot path.

Output: Working overlay theme, cached overlay position for level callbacks, single settings read for feedback sounds.
</objective>

<execution_context>
@C:/Users/hsbaz/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hsbaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src/overlay/main.tsx
@src-tauri/src/overlay.rs
@src-tauri/src/audio_feedback.rs
@src-tauri/src/settings.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix overlay theme initialization using Tauri store</name>
  <files>src/overlay/main.tsx</files>
  <action>
**Finding 2 — Overlay calls non-existent `get_settings` command (overlay/main.tsx:35,54):**

The overlay calls `invoke("get_settings")` which is NOT a registered Tauri command. This always throws, falling through to the catch block, making the overlay always use system theme.

Replace the `initializeTheme()` function to read `theme_mode` directly from the Tauri store plugin (same approach the main window uses via settingsStore.ts):

```typescript
async function initializeTheme() {
  try {
    const { load } = await import("@tauri-apps/plugin-store");
    const store = await load("settings_store.json", { autoSave: false, defaults: {} });
    const settings = await store.get("settings") as { theme_mode?: ThemeMode } | null;
    const themeMode = settings?.theme_mode || "system";
    applyTheme(getEffectiveTheme(themeMode));
  } catch {
    // Default to system theme on error
    applyTheme(getSystemTheme());
  }
}
```

Also update the `setupThemeListener` system theme change handler to use the same store approach instead of `invoke("get_settings")`:

```typescript
mediaQuery.addEventListener("change", async () => {
    try {
      const { load } = await import("@tauri-apps/plugin-store");
      const store = await load("settings_store.json", { autoSave: false, defaults: {} });
      const settings = await store.get("settings") as { theme_mode?: ThemeMode } | null;
      if (settings?.theme_mode === "system") {
        applyTheme(getSystemTheme());
      }
    } catch {
      // Ignore errors
    }
  });
```

This eliminates the dependency on a non-existent Tauri command and reads directly from the store file, consistent with how the main window reads settings.
  </action>
  <verify>
Run `bun run build` to verify TypeScript compiles. Verify no references to `invoke("get_settings")` remain in overlay/main.tsx.
  </verify>
  <done>
Overlay theme initializes by reading from Tauri store plugin. No more calls to non-existent `get_settings` command.
  </done>
</task>

<task type="auto">
  <name>Task 2: Cache overlay position and reduce audio feedback settings reads</name>
  <files>src-tauri/src/overlay.rs, src-tauri/src/audio_feedback.rs</files>
  <action>
**Finding 7 — emit_levels reads settings on every callback (overlay.rs:296-316):**

`emit_levels` is called many times per second during recording. It currently calls `settings::get_settings(app_handle)` every time (line 307), which deserializes the full settings JSON from the Tauri store.

Fix: Cache the overlay position in a static `AtomicU8`. Update the cache when the setting changes.

1. Add a static atomic at the top of overlay.rs:
```rust
use std::sync::atomic::AtomicU8;

/// Cached overlay position to avoid reading settings on every audio level callback.
/// Values: 0 = None, 1 = Top, 2 = Bottom
static CACHED_OVERLAY_POSITION: AtomicU8 = AtomicU8::new(2); // Default: Bottom
```

2. Add a function to update the cache:
```rust
/// Updates the cached overlay position. Call this when the setting changes.
pub fn update_cached_overlay_position(position: OverlayPosition) {
    let val = match position {
        OverlayPosition::None => 0,
        OverlayPosition::Top => 1,
        OverlayPosition::Bottom => 2,
    };
    CACHED_OVERLAY_POSITION.store(val, Ordering::Relaxed);
}

fn get_cached_overlay_position() -> OverlayPosition {
    match CACHED_OVERLAY_POSITION.load(Ordering::Relaxed) {
        0 => OverlayPosition::None,
        1 => OverlayPosition::Top,
        _ => OverlayPosition::Bottom,
    }
}
```

3. In `emit_levels`, replace the settings read (lines 307-308):
```rust
let current_settings = settings::get_settings(app_handle);
if current_settings.overlay_position != OverlayPosition::None {
```
with:
```rust
if get_cached_overlay_position() != OverlayPosition::None {
```

4. In `show_recording_overlay`, replace the settings reads with cached position. The function already reads settings for the `OverlayPosition::None` check — keep that one since it's called infrequently. But also update the cache:
   - After `let settings = settings::get_settings(app_handle);` add: `update_cached_overlay_position(settings.overlay_position);`

5. In `change_overlay_position_setting` (shortcut.rs), the overlay position update already calls `update_overlay_position`. Also call `update_cached_overlay_position` there. But since shortcut.rs shouldn't directly call overlay internals, instead update the cache inside `update_overlay_position`:
   - At the start of `update_overlay_position`, add:
   ```rust
   let settings = settings::get_settings(app_handle);
   update_cached_overlay_position(settings.overlay_position);
   ```

6. Also update the cache in `create_recording_overlay` by calling `update_cached_overlay_position` with the current setting.

**Finding 8 — Multiple settings reads in play_feedback_sound (audio_feedback.rs:19,33,43-58):**

`play_feedback_sound` calls `get_settings` at line 58, `get_sound_path` calls it again at line 43, and `play_sound` calls it at line 19 (for volume) and again at line 33 (for output device). That's 4 settings reads for one sound event.

Fix: Read settings once in `play_feedback_sound` and pass the needed values through:

1. Change `get_sound_path` to accept settings reference:
```rust
fn get_sound_path(settings: &crate::settings::AppSettings, sound_type: SoundType) -> String {
    match sound_type {
        SoundType::Start => match settings.sound_theme {
            crate::settings::SoundTheme::Custom => "custom_start.wav".to_string(),
            _ => settings.sound_theme.to_start_path(),
        },
        SoundType::Stop => match settings.sound_theme {
            crate::settings::SoundTheme::Custom => "custom_stop.wav".to_string(),
            _ => settings.sound_theme.to_stop_path(),
        },
    }
}
```

2. Change `play_sound` to accept volume, output device, and base_dir directly instead of reading settings:
```rust
fn play_sound(
    app: &AppHandle,
    resource_path: &str,
    base_dir: tauri::path::BaseDirectory,
    volume: f32,
    selected_output_device: Option<String>,
) {
    let app_handle = app.clone();
    let resource_path = resource_path.to_string();

    thread::spawn(move || {
        let audio_path = match app_handle.path().resolve(&resource_path, base_dir) {
            Ok(path) => path.to_path_buf(),
            Err(e) => {
                error!("Failed to resolve audio file path '{}': {}", resource_path, e);
                return;
            }
        };

        if let Err(e) = play_audio_file(&audio_path, selected_output_device, volume) {
            error!("Failed to play sound '{}': {}", resource_path, e);
        }
    });
}
```

3. Update `play_feedback_sound` to read settings once and pass values:
```rust
pub fn play_feedback_sound(app: &AppHandle, sound_type: SoundType) {
    let settings = settings::get_settings(app);
    if !settings.audio_feedback {
        return;
    }

    let sound_file = get_sound_path(&settings, sound_type);
    let base_dir = if settings.sound_theme == crate::settings::SoundTheme::Custom {
        tauri::path::BaseDirectory::AppData
    } else {
        tauri::path::BaseDirectory::Resource
    };
    play_sound(app, &sound_file, base_dir, settings.audio_feedback_volume, settings.selected_output_device.clone());
}
```

4. Similarly update `play_test_sound`:
```rust
pub fn play_test_sound(app: &AppHandle, sound_type: SoundType) {
    let settings = settings::get_settings(app);
    let sound_file = get_sound_path(&settings, sound_type);
    let base_dir = if settings.sound_theme == crate::settings::SoundTheme::Custom {
        tauri::path::BaseDirectory::AppData
    } else {
        tauri::path::BaseDirectory::Resource
    };
    play_sound(app, &sound_file, base_dir, settings.audio_feedback_volume, settings.selected_output_device.clone());
}
```
  </action>
  <verify>
Run `cargo check` from src-tauri/. Verify no `get_settings` call remains inside `emit_levels`. Verify `play_sound` no longer calls `get_settings`. Count `get_settings` calls in audio_feedback.rs — should be exactly 2 (one in `play_feedback_sound`, one in `play_test_sound`).
  </verify>
  <done>
emit_levels uses cached overlay position (AtomicU8) instead of reading settings from disk. play_feedback_sound reads settings exactly once per invocation and passes values to helpers.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes in src-tauri/
2. `bun run build` passes (frontend TypeScript)
3. No `invoke("get_settings")` calls in overlay/main.tsx
4. No `settings::get_settings` call in `emit_levels` function body
5. `audio_feedback.rs` has exactly 2 `get_settings` calls (one per public function)
</verification>

<success_criteria>
Overlay theme works correctly from Tauri store. Hot-path audio callbacks use cached position. Feedback sound plays with single settings read.
</success_criteria>

<output>
After completion, create `.planning/phases/11-fix-all-audit-findings/11-02-SUMMARY.md`
</output>
