---
phase: 11-fix-all-audit-findings
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/src/managers/history.rs
  - src-tauri/src/managers/transcription.rs
  - src-tauri/src/managers/audio.rs
  - src-tauri/src/actions.rs
autonomous: true

must_haves:
  truths:
    - "HistoryEntry row mapping is defined exactly once and reused across all query methods"
    - "audio.is_empty() is used instead of audio.len() == 0"
    - "No commented-out println remains in audio.rs"
    - "save_transcription receives active_profile_id from settings instead of hardcoded None"
  artifacts:
    - path: "src-tauri/src/managers/history.rs"
      provides: "Shared row_to_history_entry function"
      contains: "fn row_to_history_entry"
    - path: "src-tauri/src/managers/transcription.rs"
      provides: "Clippy-clean empty check"
      contains: "audio.is_empty()"
    - path: "src-tauri/src/actions.rs"
      provides: "Active profile ID passed to save_transcription"
      contains: "settings.active_profile_id"
  key_links:
    - from: "src-tauri/src/managers/history.rs"
      to: "row_to_history_entry"
      via: "All query methods call shared function"
      pattern: "row_to_history_entry"
---

<objective>
Clean up code health issues: extract duplicated history row mapping, fix clippy warning, remove dead code, and wire up the active profile ID.

Purpose: Reduce maintenance burden from copy-pasted code, fix a clippy lint, remove dead commented code, and connect an existing but unwired feature.

Output: DRY history module, clean transcription code, wired profile ID.
</objective>

<execution_context>
@C:/Users/hsbaz/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hsbaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src-tauri/src/managers/history.rs
@src-tauri/src/managers/transcription.rs
@src-tauri/src/managers/audio.rs
@src-tauri/src/actions.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract shared row_to_history_entry function in history.rs</name>
  <files>src-tauri/src/managers/history.rs</files>
  <action>
**Finding 5 — Duplicated HistoryEntry row mapping (history.rs, 7 locations):**

The exact same 11-field row-to-HistoryEntry mapping closure is copy-pasted in:
1. `get_history_entries` (line 348-361)
2. `get_entry_by_id` (line 412-425)
3. `search_transcriptions` (line 500-513)
4. `get_by_profile` (line 537-550)
5. `get_by_date_range` (line 579-592)
6. `get_saved_only` (line 616-629)

Extract a shared function:
```rust
fn row_to_history_entry(row: &rusqlite::Row) -> rusqlite::Result<HistoryEntry> {
    Ok(HistoryEntry {
        id: row.get("id")?,
        file_name: row.get("file_name")?,
        timestamp: row.get("timestamp")?,
        saved: row.get("saved")?,
        title: row.get("title")?,
        transcription_text: row.get("transcription_text")?,
        ghostwritten_text: row.get("ghostwritten_text")?,
        profile_id: row.get("profile_id")?,
        notes: row.get("notes")?,
        duration_seconds: row.get("duration_seconds")?,
        word_count: row.get("word_count")?,
    })
}
```

Place this as a standalone function (not a method) right after the `HistoryEntry` struct definition, before the `impl HistoryManager` block.

Then replace all 6 inline closures with `row_to_history_entry`. For example:

In `get_history_entries`:
```rust
let rows = stmt.query_map([], row_to_history_entry)?;
```

In `get_entry_by_id`:
```rust
let entry = stmt.query_row([id], row_to_history_entry).optional()?;
```

In `search_transcriptions`:
```rust
let entries = stmt.query_map(params![query, limit as i64], row_to_history_entry)?;
```

In `get_by_profile`:
```rust
let entries = stmt.query_map(params![profile_id, limit as i64], row_to_history_entry)?;
```

In `get_by_date_range`:
```rust
let entries = stmt.query_map(params![start_timestamp, end_timestamp, limit as i64], row_to_history_entry)?;
```

In `get_saved_only`:
```rust
let entries = stmt.query_map(params![limit as i64], row_to_history_entry)?;
```

Note: `query_map` and `query_row` both accept `FnMut(&Row) -> Result<T>` which matches the function signature `fn(&Row) -> Result<HistoryEntry>`.
  </action>
  <verify>
Run `cargo check` from src-tauri/. Grep for `row_to_history_entry` in history.rs — should appear 7 times (1 definition + 6 call sites). Grep for `row.get("id")` — should appear exactly once (in the shared function).
  </verify>
  <done>
HistoryEntry row mapping is defined exactly once in `row_to_history_entry` and called from all 6 query methods. No duplicate mapping code remains.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix clippy lint, remove dead code, wire profile ID</name>
  <files>src-tauri/src/managers/transcription.rs, src-tauri/src/managers/audio.rs, src-tauri/src/actions.rs</files>
  <action>
**Finding 11 — clippy::len_zero (transcription.rs:369):**

In `src-tauri/src/managers/transcription.rs`, find:
```rust
if audio.len() == 0 {
```
Replace with:
```rust
if audio.is_empty() {
```

**Finding 12a — Commented-out println (audio.rs:311):**

In `src-tauri/src/managers/audio.rs`, find and delete the commented-out line:
```rust
// println!("Got {} samples", { s_len });
```
Remove the entire line.

**Finding 12b — Stale TODO for profile_id (actions.rs:519):**

In `src-tauri/src/actions.rs`, find the save_transcription call (around line 514-519):
```rust
if let Err(e) = hm_clone
    .save_transcription(
        samples_clone,
        transcription_for_history,
        ghostwritten_text,
        None, // TODO: Get active profile_id from settings
        Some(duration_seconds),
    )
    .await
```

The `settings` variable is available earlier in the same scope (from `let settings = get_settings(ah);` which is called before this block). Look at the surrounding code to find where settings is read, and use `settings.active_profile_id` instead of `None`.

Replace:
```rust
None, // TODO: Get active profile_id from settings
```
With:
```rust
settings.active_profile_id,
```

Make sure the `settings` variable is cloned or available in the async block. If `settings` is not directly accessible inside the `tauri::async_runtime::spawn` closure, you'll need to capture the value before the spawn:
```rust
let active_profile_id = settings.active_profile_id;
```
(before the `tauri::async_runtime::spawn(async move {` line)

Then use:
```rust
active_profile_id,
```
in the save_transcription call.
  </action>
  <verify>
Run `cargo check` from src-tauri/. Run `cargo clippy -- -W clippy::len_zero` to verify no len_zero warnings. Grep for `audio.is_empty()` in transcription.rs. Grep for commented-out `println` in audio.rs — should find none. Grep for `TODO.*profile_id` in actions.rs — should find none.
  </verify>
  <done>
Clippy len_zero lint fixed. Commented-out println removed from audio.rs. Active profile ID from settings is passed to save_transcription instead of hardcoded None.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes in src-tauri/
2. `cargo clippy` has no len_zero warning for transcription.rs
3. `row_to_history_entry` function exists and is used by all query methods
4. No commented-out println in audio.rs
5. No `None, // TODO` for profile_id in actions.rs
</verification>

<success_criteria>
History module is DRY with single row mapping function. Clippy lint resolved. Dead code removed. Profile ID wired from settings to history save.
</success_criteria>

<output>
After completion, create `.planning/phases/11-fix-all-audit-findings/11-03-SUMMARY.md`
</output>
