---
phase: 11-fix-all-audit-findings
plan: 04
type: execute
wave: 2
depends_on: [11-01, 11-03]
files_modified:
  - src-tauri/src/managers/audio.rs
  - src-tauri/src/shortcut.rs
  - src-tauri/src/commands/settings.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "AudioRecordingManager uses a single consolidated mutex for recording state"
    - "Health-check thread has an AtomicBool shutdown signal"
    - "All change_*_setting commands live in commands/settings.rs, not shortcut.rs"
    - "shortcut.rs contains only shortcut-related functions"
  artifacts:
    - path: "src-tauri/src/managers/audio.rs"
      provides: "Consolidated recording state mutex preventing deadlocks"
      contains: "RecordingInner"
    - path: "src-tauri/src/shortcut.rs"
      provides: "Only shortcut registration and binding management"
    - path: "src-tauri/src/commands/settings.rs"
      provides: "All change_*_setting Tauri commands"
      contains: "#[tauri::command]"
    - path: "src-tauri/src/lib.rs"
      provides: "Updated invoke_handler referencing commands::settings::*"
      contains: "commands::settings::"
  key_links:
    - from: "src-tauri/src/commands/settings.rs"
      to: "src-tauri/src/lib.rs"
      via: "invoke_handler registration"
      pattern: "commands::settings::"
    - from: "src-tauri/src/shortcut.rs"
      to: "src-tauri/src/lib.rs"
      via: "only shortcut commands remain in shortcut:: namespace"
      pattern: "shortcut::(change_binding|reset_binding|suspend_binding|resume_binding|refresh_shortcuts)"
---

<objective>
Fix the deadlock risk in AudioRecordingManager, add shutdown mechanism for the health-check thread, and refactor the settings god-file.

Purpose: Prevent potential deadlocks from inconsistent lock ordering, enable clean shutdown of the health-check thread, and move misplaced settings commands out of shortcut.rs into their proper home.

Output: Safe consolidated mutex, stoppable health-check thread, clean module boundaries.
</objective>

<execution_context>
@C:/Users/hsbaz/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/hsbaz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src-tauri/src/managers/audio.rs
@src-tauri/src/shortcut.rs
@src-tauri/src/commands/mod.rs
@src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Consolidate AudioRecordingManager mutexes to prevent deadlock</name>
  <files>src-tauri/src/managers/audio.rs</files>
  <action>
**Finding 4 — Potential deadlock from inconsistent lock ordering (audio.rs):**

The current `AudioRecordingManager` has 6 separate mutexes: `state`, `mode`, `recorder`, `is_open`, `is_recording`, `initial_volume`. These are acquired in different orders across methods, creating deadlock risk.

Consolidate into a single mutex wrapping an inner struct. This is the simplest fix and eliminates the ordering problem entirely.

1. Define an inner struct:
```rust
struct RecordingInner {
    state: RecordingState,
    mode: MicrophoneMode,
    recorder: Option<AudioRecorder>,
    is_open: bool,
    is_recording: bool,
    initial_volume: Option<u8>,
}
```

2. Replace the AudioRecordingManager fields:
```rust
#[derive(Clone)]
pub struct AudioRecordingManager {
    inner: Arc<Mutex<RecordingInner>>,
    app_handle: tauri::AppHandle,
}
```

3. Update `new()`:
```rust
pub fn new(app: &tauri::AppHandle) -> Result<Self, anyhow::Error> {
    let settings = get_settings(app);
    let mode = if settings.always_on_microphone {
        MicrophoneMode::AlwaysOn
    } else {
        MicrophoneMode::OnDemand
    };

    let manager = Self {
        inner: Arc::new(Mutex::new(RecordingInner {
            state: RecordingState::Idle,
            mode: mode.clone(),
            recorder: None,
            is_open: false,
            is_recording: false,
            initial_volume: None,
        })),
        app_handle: app.clone(),
    };

    if matches!(mode, MicrophoneMode::AlwaysOn) {
        manager.start_microphone_stream()?;
    }

    Ok(manager)
}
```

4. Rewrite each method to lock `inner` once at the top, then access all fields through the single guard. Key pattern:

For `start_microphone_stream`:
```rust
pub fn start_microphone_stream(&self) -> Result<(), anyhow::Error> {
    let mut inner = self.inner.lock().unwrap();
    if inner.is_open {
        debug!("Microphone stream already active");
        return Ok(());
    }
    // ... rest of method using inner.field instead of self.field.lock().unwrap()
}
```

Important: For `stop_microphone_stream`, the method currently acquires locks one at a time. With the consolidated mutex, just lock once:
```rust
pub fn stop_microphone_stream(&self) {
    let mut inner = self.inner.lock().unwrap();
    if !inner.is_open {
        return;
    }
    if let Some(vol) = inner.initial_volume {
        cpvc::set_system_volume(vol);
    }
    inner.initial_volume = None;
    if let Some(rec) = inner.recorder.as_mut() {
        if inner.is_recording {
            let _ = rec.stop();
            inner.is_recording = false;
        }
        let _ = rec.close();
    }
    inner.is_open = false;
    debug!("Microphone stream stopped");
}
```

For `try_start_recording`:
```rust
pub fn try_start_recording(&self, binding_id: &str) -> bool {
    let mut inner = self.inner.lock().unwrap();
    if !matches!(inner.state, RecordingState::Idle) {
        return false;
    }
    if matches!(inner.mode, MicrophoneMode::OnDemand) {
        // Need to drop lock before calling start_microphone_stream which also locks
        drop(inner);
        if let Err(e) = self.start_microphone_stream() {
            error!("Failed to open microphone stream: {e}");
            return false;
        }
        inner = self.inner.lock().unwrap();
    }
    if let Some(rec) = inner.recorder.as_ref() {
        if rec.start().is_ok() {
            inner.is_recording = true;
            inner.state = RecordingState::Recording {
                binding_id: binding_id.to_string(),
            };
            debug!("Recording started for binding {binding_id}");
            return true;
        }
    }
    error!("Recorder not available");
    false
}
```

For `stop_recording`: Lock once, do all state changes, then drop lock before calling `stop_microphone_stream`:
```rust
pub fn stop_recording(&self, binding_id: &str) -> Option<Vec<f32>> {
    let mut inner = self.inner.lock().unwrap();
    match &inner.state {
        RecordingState::Recording { binding_id: active } if active == binding_id => {
            inner.state = RecordingState::Idle;
            let samples = if let Some(rec) = inner.recorder.as_ref() {
                match rec.stop() {
                    Ok(buf) => buf,
                    Err(e) => {
                        error!("stop() failed: {e}");
                        Vec::new()
                    }
                }
            } else {
                error!("Recorder not available");
                Vec::new()
            };
            inner.is_recording = false;
            let should_close = matches!(inner.mode, MicrophoneMode::OnDemand);
            drop(inner);

            if should_close {
                self.stop_microphone_stream();
            }

            let s_len = samples.len();
            if s_len < WHISPER_SAMPLE_RATE && s_len > 0 {
                let mut padded = samples;
                padded.resize(WHISPER_SAMPLE_RATE * 5 / 4, 0.0);
                Some(padded)
            } else {
                Some(samples)
            }
        }
        _ => None,
    }
}
```

For `cancel_recording`:
```rust
pub fn cancel_recording(&self) {
    let mut inner = self.inner.lock().unwrap();
    if let RecordingState::Recording { .. } = inner.state {
        inner.state = RecordingState::Idle;
        if let Some(rec) = inner.recorder.as_ref() {
            let _ = rec.stop();
        }
        inner.is_recording = false;
        let should_close = matches!(inner.mode, MicrophoneMode::OnDemand);
        drop(inner);
        if should_close {
            self.stop_microphone_stream();
        }
    }
}
```

For `update_mode`:
```rust
pub fn update_mode(&self, new_mode: MicrophoneMode) -> Result<(), anyhow::Error> {
    let inner = self.inner.lock().unwrap();
    let cur_mode = inner.mode.clone();
    let is_idle = matches!(inner.state, RecordingState::Idle);
    drop(inner);

    match (cur_mode, &new_mode) {
        (MicrophoneMode::AlwaysOn, MicrophoneMode::OnDemand) => {
            if is_idle {
                self.stop_microphone_stream();
            }
        }
        (MicrophoneMode::OnDemand, MicrophoneMode::AlwaysOn) => {
            self.start_microphone_stream()?;
        }
        _ => {}
    }

    self.inner.lock().unwrap().mode = new_mode;
    Ok(())
}
```

For `update_selected_device`:
```rust
pub fn update_selected_device(&self) -> Result<(), anyhow::Error> {
    if self.inner.lock().unwrap().is_open {
        self.stop_microphone_stream();
        self.start_microphone_stream()?;
    }
    Ok(())
}
```

**IMPORTANT**: Where methods call other methods that also lock (e.g., `try_start_recording` calling `start_microphone_stream`), you MUST drop the lock before the nested call to avoid self-deadlock. The pattern is: read what you need, drop the guard, call the nested method, re-acquire if needed.
  </action>
  <verify>
Run `cargo check` from src-tauri/. Verify `AudioRecordingManager` has exactly one `Arc<Mutex<RecordingInner>>` field (plus `app_handle`). Verify no other `Arc<Mutex<...>>` fields remain.
  </verify>
  <done>
AudioRecordingManager uses a single consolidated `RecordingInner` mutex. No risk of inconsistent lock ordering. Self-deadlock avoided by dropping lock before nested calls.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add thread shutdown + refactor settings commands out of shortcut.rs</name>
  <files>src-tauri/src/shortcut.rs, src-tauri/src/commands/settings.rs, src-tauri/src/commands/mod.rs, src-tauri/src/lib.rs</files>
  <action>
**Finding 10 — Health-check thread loops forever (shortcut.rs:24-30):**

Add an `AtomicBool` shutdown signal for the health-check thread.

1. At the top of shortcut.rs, add:
```rust
use std::sync::atomic::{AtomicBool, Ordering};

static HEALTH_CHECK_SHUTDOWN: AtomicBool = AtomicBool::new(false);
```

2. In `init_shortcuts`, replace the thread spawn (lines 24-30):
```rust
let app_clone = app.clone();
std::thread::spawn(move || {
    loop {
        std::thread::sleep(std::time::Duration::from_secs(10));
        if HEALTH_CHECK_SHUTDOWN.load(Ordering::Relaxed) {
            debug!("Health check thread shutting down");
            break;
        }
        verify_and_reregister_shortcuts(&app_clone);
    }
});
```

3. Add a public shutdown function:
```rust
/// Signal the health-check thread to stop.
pub fn shutdown_health_check() {
    HEALTH_CHECK_SHUTDOWN.store(true, Ordering::Relaxed);
}
```

**Finding 6 — shortcut.rs is a settings god-file:**

Move all `change_*_setting` commands from shortcut.rs to a new `commands/settings.rs` module. Keep only shortcut-specific commands in shortcut.rs.

1. Create `src-tauri/src/commands/settings.rs` with all the settings commands moved from shortcut.rs:
   - `change_ptt_setting`
   - `change_audio_feedback_setting`
   - `change_audio_feedback_volume_setting`
   - `change_sound_theme_setting`
   - `change_translate_to_english_setting`
   - `change_selected_language_setting`
   - `change_overlay_position_setting`
   - `change_debug_mode_setting`
   - `change_start_hidden_setting`
   - `change_autostart_setting`
   - `update_custom_words`
   - `change_word_correction_threshold_setting`
   - `change_paste_method_setting`
   - `change_clipboard_handling_setting`
   - `change_mute_while_recording_setting`
   - `change_output_mode_setting`
   - `get_openrouter_api_key_setting`
   - `change_openrouter_api_key_setting`
   - `change_openrouter_model_setting`
   - `change_custom_instructions_setting`

The new file needs these imports at the top:
```rust
use log::{debug, warn};
use tauri::{AppHandle, Emitter, Manager};
use tauri_plugin_autostart::ManagerExt;

use crate::settings::{self, ClipboardHandling, OverlayPosition, PasteMethod, SoundTheme};
```

Each moved function keeps its `#[tauri::command]` attribute and `pub` visibility.

2. Update `commands/mod.rs` to add:
```rust
pub mod settings;
```

3. Delete the moved functions from `shortcut.rs`. After removal, shortcut.rs should only contain:
   - `init_shortcuts`
   - `shutdown_health_check`
   - `verify_and_reregister_shortcuts`
   - `BindingResponse` struct
   - `change_binding`
   - `reset_binding`
   - `validate_shortcut_string`
   - `suspend_binding`
   - `resume_binding`
   - `refresh_shortcuts`
   - `_register_shortcut`
   - `_unregister_shortcut`

4. Update `lib.rs` invoke_handler: Change all `shortcut::change_*` and `shortcut::update_*` and `shortcut::get_openrouter_*` references to `commands::settings::*`. Keep `shortcut::change_binding`, `shortcut::reset_binding`, `shortcut::suspend_binding`, `shortcut::resume_binding`, `shortcut::refresh_shortcuts` as-is since those are actual shortcut commands.

Specifically, replace these entries:
```rust
shortcut::change_ptt_setting,
shortcut::change_audio_feedback_setting,
shortcut::change_audio_feedback_volume_setting,
shortcut::change_sound_theme_setting,
shortcut::change_start_hidden_setting,
shortcut::change_autostart_setting,
shortcut::change_translate_to_english_setting,
shortcut::change_selected_language_setting,
shortcut::change_overlay_position_setting,
shortcut::change_debug_mode_setting,
shortcut::change_word_correction_threshold_setting,
shortcut::change_paste_method_setting,
shortcut::change_clipboard_handling_setting,
shortcut::update_custom_words,
shortcut::change_mute_while_recording_setting,
shortcut::change_output_mode_setting,
shortcut::get_openrouter_api_key_setting,
shortcut::change_openrouter_api_key_setting,
shortcut::change_openrouter_model_setting,
shortcut::change_custom_instructions_setting,
```
With:
```rust
commands::settings::change_ptt_setting,
commands::settings::change_audio_feedback_setting,
commands::settings::change_audio_feedback_volume_setting,
commands::settings::change_sound_theme_setting,
commands::settings::change_start_hidden_setting,
commands::settings::change_autostart_setting,
commands::settings::change_translate_to_english_setting,
commands::settings::change_selected_language_setting,
commands::settings::change_overlay_position_setting,
commands::settings::change_debug_mode_setting,
commands::settings::change_word_correction_threshold_setting,
commands::settings::change_paste_method_setting,
commands::settings::change_clipboard_handling_setting,
commands::settings::update_custom_words,
commands::settings::change_mute_while_recording_setting,
commands::settings::change_output_mode_setting,
commands::settings::get_openrouter_api_key_setting,
commands::settings::change_openrouter_api_key_setting,
commands::settings::change_openrouter_model_setting,
commands::settings::change_custom_instructions_setting,
```

5. Remove now-unused imports from shortcut.rs. After moving the settings commands, shortcut.rs no longer needs:
   - `settings::ClipboardHandling`
   - `settings::OverlayPosition`
   - `settings::PasteMethod`
   - `settings::SoundTheme`
   - `tauri_plugin_autostart::ManagerExt`
   - `tauri::Emitter`

Keep the imports that are still used by the remaining shortcut functions.
  </action>
  <verify>
Run `cargo check` from src-tauri/. Verify shortcut.rs no longer contains any `change_*_setting` or `update_custom_words` or `get_openrouter_*` functions. Verify `commands/settings.rs` exists and contains all moved functions. Verify lib.rs references `commands::settings::*` for all settings commands.
  </verify>
  <done>
Health-check thread has AtomicBool shutdown signal. All settings commands moved to commands/settings.rs. shortcut.rs contains only shortcut-related code. lib.rs invoke_handler updated.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes in src-tauri/
2. `bun run build` passes (frontend unchanged)
3. AudioRecordingManager has single consolidated mutex
4. shortcut.rs has no `change_*_setting` functions
5. commands/settings.rs exists with all settings commands
6. Health-check thread checks HEALTH_CHECK_SHUTDOWN flag
</verification>

<success_criteria>
Deadlock risk eliminated via consolidated mutex. Health-check thread can be cleanly stopped. Settings commands live in their proper module. shortcut.rs is focused on shortcuts only.
</success_criteria>

<output>
After completion, create `.planning/phases/11-fix-all-audit-findings/11-04-SUMMARY.md`
</output>
